# Q 0 : # @abuse_reports.includes(:reporter, :user)
Query(AbuseReport)
.includes('reporter')
.includes('user')
.return_limit('40')
# Q 1 : # @builds.select(&:included?)
# Q 2 : # @commit.pipelines.order(id: :desc)
Query(CiPipeline)
.where('project_id = ?')
.order('id')
# Q 3 : # @commits.map(&:author_email).uniq.size
Query(MergeRequestDiffCommit)
.where("id IN (?, ?, ?)")
.select("author_email")
.distinct('')
# Q 7 : # @group.labels.find(params[:id])
Query(GroupLabel)
.where('group_id = ?')
.where("id = ?")
# Q 8 : # @group.notification_settings(hierarchy_order: :asc).where(user: user).where.not(level: NotificationSetting.levels[:global]).first
Query(NotificationSetting)
.where('source_id = ?')
.where("source_type = 'Group'")
.where("user_id = ?")
.where("level = ?")
.return_limit('1')
# Q 9 : # @group.projects.find(params[:project_id])
Query(Project)
.where('group_id = ?')
.where("id = ?")
# Q 10 : # @group.runners.find(params[:id])
Query(Group)
.where("id = ?")
# Q 11 : # @merge_request.merge_request_diffs.viewable.find_by(id: diff_id)
Query(MergeRequestDiff)
.where("merge_request_id = ?")
.where("id = ?")
# Q 12 : # @merge_request.merge_request_diffs.viewable.order_id_desc
Query(MergeRequestDiff)
.where("merge_request_id = ?")
.order('id')
# Q 13 : # @merge_request.notes.where(commit_id: @commit.id).inc_relations_for_view
Query(Note)
.where('noteable_id = ?')
.where("noteable_type = 'MergeRequest'")
.where("commit_id = ?")
# Q 14 : # @project.all_lfs_objects.where(oid: new_lfs_pointers.map(&:lfs_oid)).count
Query(LfsObjectsProject)
.joins('lfs_object')
.where('project_id = ?')
.where("lfs_object.oid = ?")
# Q 15 : # @project.ci_pipelines.where(sha: @sha).latest_status(@ref)
Query(CiPipeline)
.where("project_id = ?")
.where("sha = ?")
# Q 16 : # @project.deploy_tokens.find(params[:id])
Query(DeployToken)
.includes('projects')
.where("projects.id = ?")
.where("id = ?")
# Q 17 : # @project.deployments.success.where("created_at >= ?", @from)
Query(Deployment)
.where("project_id = ?")
# Q 19 : # @project.forked_from_project
Query(Project)
.where("id = ?")
# Q 20 : # @project.group
Query(Group)
.where("id = ?")
# Q 21 : # @project.group
Query(Group)
.where("id = ?")
# Q 22 : # @project.group
Query(Group)
.where("id = ?")
# Q 23 : # @project.group
Query(Group)
.where("id = ?")
# Q 24 : # @project.group.ancestors.pluck(:id)
Query(Group)
.where("parent_id = ?")
.select('id')
# Q 25 : # @project.hooks.find(params[:hook_id])
Query(ProjectHook)
.where("project_id = ?")
.where("id = ?")
# Q 26 : # @project.hooks.find(params[:id])
Query(ProjectHook)
.where("project_id = ?")
.where("id = ?")
# Q 27 : # @project.hooks.select(&:persisted?)
Query(ProjectHook)
.where("project_id = ?")
# Q 28 : # @project.issues.includes(author: :status).where(iid: params[:id]).reorder(nil).take!
Query(Issue)
.where("project_id = ?")
.where("iid = ?")
# Q 29 : # @project.labels.find(params[:id])
Query(ProjectLabel)
.where("project_id = ?")
.where("id = ?")
# Q 30 : # @project.labels.pluck(:id, :name).each_with_object({ })
Query(ProjectLabel)
.where("project_id = ?")
.select('id')
# Q 31 : # @project.merge_requests.find_by(iid: parsed_relation_hash["iid"])
Query(MergeRequest)
.joins('source_project')
.where("source_project.id = ?")
.where("iid = ?")
# Q 32 : # @project.merge_requests.with_state(:locked).where(in_progress_merge_commit_sha: @newrev, target_branch: @branch_name).exists?
Query(MergeRequest)
.joins('source_project')
.where("source_project.id = ?")
.where("in_progress_merge_commit_sha = ?")
.where("target_branch = ?")
.return_limit('1')
# Q 33 : # @project.milestones.find_by!(iid: params[:id])
Query(Milestone)
.where("project_id = ?")
.where("iid = ?")
# Q 34 : # @project.milestones.pluck(:id, :iid).each_with_object({ })
Query(Milestone)
.where("project_id = ?")
.select('id')
.select('iid')
# Q 35 : # @project.notes.find(params[:id])
Query(Note)
.where("project_id = ?")
.where("id = ?")
# Q 36 : # @project.notes.where("noteable_type = ?", "Commit").group("notes.commit_id").select("notes.commit_id, count(notes.id) as note_count").each
Query(Note)
.where("project_id = ?")
.where("noteable_type = 'Commit'")
.group('commit_id')
.select('commit_id')
# Q 37 : # @project.pages_domains.find_by_domain!(params[:id].to_s)
Query(PagesDomain)
.where("project_id = ?")
.where("domain != ?")
# Q 38 : # @project.pages_domains.order(:domain)
Query(PagesDomain)
.where("project_id = ?")
.order('domain')
# Q 39 : # @project.project_group_links
Query(ProjectGroupLink)
.where("project_id = ?")
# Q 40 : # @project.project_group_links.find(params[:id])
Query(ProjectGroupLink)
.where("project_id = ?")
.where("id = ?")
# Q 41 : # @project.project_members.where.not(user_id: nil).select(:user_id)
Query(ProjectMember)
.where("project_id = ?")
.where("user_id = ?")
.select('user_id')
# Q 42 : # @project.protected_branches.find(params[:id])
Query(ProtectedBranch)
.where("project_id = ?")
.where("id = ?")
# Q 43 : # @project.protected_branches.order(:name).page(params[:page])
Query(ProtectedBranch)
.where("project_id = ?")
.order('name')
# Q 44 : # @project.protected_tags.find(params[:id])
Query(ProtectedTag)
.where("project_id = ?")
.where("id = ?")
# Q 45 : # @project.protected_tags.order(:name).page(params[:page])
Query(ProtectedTag)
.where("project_id = ?")
.order('name')
# Q 46 : # @project.releases.find_or_initialize_by(tag: @tag.name)
Query(Release)
.where("project_id = ?")
# Q 47 : # @project.snippets.inc_relations_for_view.find(params[:id])
Query(ProjectSnippet)
.where("project_id = ?")
.where("id = ?")
# Q 50 : # @project_members.joins(:user).merge(User.search(params[:search]))
Query(ProjectMember)
.joins('user')
.where('user.id IN (?, ?)')
# Q 51 : # @project_wiki.find_page("home", params[:version_id])
Query(ProjectWiki)
.where('id = ?')
.where('page = ?')
# Q 53 : # Ability.allowed?(user, :read_group, extra_group)
Query(Ability)

# Q 54 : # Ability.allowed?(opts[:user], :admin_group, namespace)
Query(Ability)

# Q 55 : # AbuseReport.find(params[:id])
Query(AbuseReport)
.where("id = ?")
# Q 56 : # AbuseReport.order(id: :desc).page(params[:page])
Query(AbuseReport)
.order('id')
# Q 57 : # AuditEvent.where(entity_type: "User", entity_id: user.id).order("created_at DESC").page(params[:page])
Query(AuditEvent)
.where("entity_type = ?")
.where("entity_id = ?")
.order('created_at')
# Q 58 : # Board.find(params[:board_id])
Query(Board)
.where("id = ?")
# Q 59 : # BroadcastMessage.find(params[:id])
Query(BroadcastMessage)
.where("id = ?")
# Q 60 : # BroadcastMessage.find(params[:id])
Query(BroadcastMessage)
.where("id = ?")
# Q 61 : # BroadcastMessage.order(ends_at: :desc).page(params[:page])
Query(BroadcastMessage)
.order('ends_at')
# Q 62 : # Ci::RunnerNamespace.where(namespace_id: owned_or_maintainers_groups.select(:id)).joins(:runner).select("ci_runners.*")
Query(CiRunnerNamespace)
.where("namespace_id = ?")
.joins('runner')
# Q 63 : # Ci::RunnerProject.where(project: authorized_projects(Gitlab::Access::MAINTAINER)).joins(:runner).select("ci_runners.*")
Query(CiRunnerProject)
.where("project = ?")
.joins('runner')
# Q 64 : # Clusters::Cluster.joins(:groups).where(cluster_groups: { group_id: ancestors_upto })
Query(ClustersCluster)
.joins('groups')
.where("groups.id = ?")
# Q 65 : # CommitStatus.from(stages_query, :sg).pluck("sg.stage", status_sql, "(#{
# warnings_sql})")
# Q 66 : # CommitStatus.where(id: @jobs).legacy_status
Query(CommitStatus)
.where("id = ?")
# Q 68 : # ConversationalDevelopmentIndex::Metric.order(:created_at).last.present
Query(ConversationalDevelopmentIndexMetric)
.order('created_at')
.return_limit('1')
# Q 69 : # DeployKey.find(deploy_key_matches[1])
Query(DeployKey)
.where("id = ?")
# Q 70 : # DeployKey.find(params[:id])
Query(DeployKey)
.where("id = ?")
# Q 71 : # DeployKey.in_projects(authorized_projects.select(:id)).distinct(:id)
Query(DeployKey)
.joins('projects')
.where('projects.id = ?')
.distinct('')
# Q 72 : # DeployToken.active.find_by_token(password)
Query(DeployToken)
.where("token = ?")
# Q 73 : # Deployment.find_by(id: deployment_id).try
Query(Deployment)
.where("id = ?")
# Q 74 : # Deployment.find_by(id: deployment_id).try
Query(Deployment)
.where("id = ?")
# Q 75 : # Deployment.joins(:project).merge(Project.inside_path(group.full_path))
Query(Deployment)
.joins('project')
# Q 76 : # Deployment.where(environment: environment).find_by_sha(sha)
Query(Deployment)
.where("environment = ?")
.where("sha = ?")
# Q 77 : # Environment.find_by(name: expanded_environment_name, project: project)
Query(Environment)
.where("name = ?")
.where("project = ?")
# Q 78 : # Event.contributions.where(author_id: contributor.id).where(created_at: date.beginning_of_day..date.end_of_day).where(project_id: projects).with_associations
Query(Event)
.where("((action = 1) || ((target_type = 2) AND (action = 2))) || ((target_type = 3) AND (action = 3))")
.where("author_id = ?")
.where("created_at > ?")
.where("project_id IN (?, ?)")
# Q 81 : # Event.reorder(nil).select(t[:project_id], t[:target_type], t[:action], "date(created_at + #{
# date_interval}) AS date", "count(id) as total_amount").group(t[:project_id], t[:target_type], t[:action], "date(created_at + #{
# date_interval})").where(conditions).where("events.project_id in (#{
# authed_projects.to_sql})")
# Q 82 : # Event.select(:project_id).contributions.where(author_id: self).where("created_at > ?", Time.now - 1.year).distinct.reorder(nil)
Query(Event)
.select('project_id')
.where("((action = 1) || ((target_type = 2) AND (action = 2))) || ((target_type = 3) AND (action = 3))")
.where("author_id = ?")
.where('created_at > ?')
.distinct('')
# Q 85 : # GpgKey.find_by_fingerprint(fingerprint)
Query(GpgKey)
.where("fingerprint = ?")
# Q 86 : # GpgKey.find_by_primary_keyid(fingerprint)
Query(GpgKey)
.where("primary_keyid = ?")
# Q 87 : # GpgKeySubkey.find_by_fingerprint(fingerprint)
Query(GpgKeySubkey)
.where("fingerprint = ?")
# Q 88 : # GpgKeySubkey.find_by_keyid(fingerprint)
Query(GpgKeySubkey)
.where("key = ?")
# Q 89 : # GpgSignature.select(:id, :commit_sha, :project_id).where("gpg_key_id IS NULL OR verification_status <> ?", GpgSignature.verification_statuses[:verified]).where(gpg_key_primary_keyid: @gpg_key.keyids).find_each
Query(GpgSignature)
.select('id')
.select('commit_sha')
.select('project_id')
.where("gpg_key_primary_keyid = ?")
# Q 90 : # GpgSignature.where(commit_sha: commit_shas).pluck(:commit_sha)
Query(GpgSignature)
.where("commit_sha IN (?, ?)")
.select('commit_sha')
# Q 91 : # Group.find(extra_group)
Query(Group)
.where("id = ?")
# Q 92 : # Group.find(group_id)
Query(Group)
.where("id = ?")
# Q 93 : # Group.find(params[:group_id])
Query(Group)
.where("id = ?")
# Q 94 : # Group.find(params[:link_group_id])
Query(Group)
.where("id = ?")
# Q 95 : # Group.find(params[:namespace_id])
Query(Group)
.where("id = ?")
# Q 96 : # Group.find(params[:shared_with_group_id])
Query(Group)
.where("id = ?")
# Q 97 : # Group.find_by(id: id)
Query(Group)
.where("id = ?")
# Q 98 : # Group.find_by(id: params[:new_parent_group_id])
Query(Group)
.where("id = ?")
# Q 99 : # Group.find_by(id: params[:parent_id])
Query(Group)
.where("id = ?")
# Q 100 : # Group.find_by(id: parent_id_before_last_save)
Query(Group)
.where("id = ?")
# Q 101 : # Group.find_by(id: session[:manifest_import_group_id])
Query(Group)
.where("id = ?")
# Q 102 : # Group.find_by(path: extra_group.path)
Query(Group)
.where("path = ?")
# Q 103 : # Group.find_by_full_path(full_path, follow_redirects: request.get?).present?
Query(Group)
.where("full_path = ?")
# Q 104 : # Group.find_by_full_path(group)
Query(Group)
.where("full_path = ?")
# Q 105 : # Group.find_by_full_path(group_id)
Query(Group)
.where("full_path = ?")
# Q 106 : # Group.find_by_full_path(id)
Query(Group)
.where("full_path = ?")
# Q 107 : # Group.find_by_full_path(params[:group])
Query(Group)
.where("full_path = ?")
# Q 108 : # Group.find_by_full_path(params[:id])
Query(Group)
.where("full_path = ?")
# Q 109 : # Group.find_by_id(allowed_group_id)
Query(Group)
.where("id = ?")
# Q 110 : # Group.find_by_id(performance_bar_allowed_group_id)
Query(Group)
.where("id = ?")
# Q 111 : # Group.joins(project_group_links: :project).where(projects: { namespace_id: id }).find_each(&:refresh_members_authorized_projects)
Query(Group)
.joins('project_group_links => project')
.where('project_group_links.project.namespace_id = ?')
# Q 113 : # Group.with_statistics.find(group.id)
Query(Group)
.where("id = ?")
# Q 114 : # GroupGroupLink.where(shared_group_id: self_and_ancestors_ids)
Query(GroupGroupLink)
.where("shared_group_id IN (?, ?)")
# Q 115 : # GroupMember.active_without_invites_and_requests.where(source_id: self_and_descendants.reorder(nil).select(:id))
Query(GroupMember)
.where("source_id = ?")
# Q 116 : # GroupMember.active_without_invites_and_requests.where(source_id: self_and_hierarchy.reorder(nil).select(:id))
Query(GroupMember)
.where("source_id = ?")
# Q 117 : # GroupMember.active_without_invites_and_requests.where(source_id: source_ids)
Query(GroupMember)
.where("source_id = ?")
# Q 118 : # GroupMember.where("user_id not in (select id from users)").exists?
Query(GroupMember)
.where("!(user_id IN (?, ?))")
.return_limit('1')
# Q 119 : # GroupMember.where(source: source.ancestors, user_id: user_id).order(:access_level).last
Query(GroupMember)
.where("source_id IN (?, ?)")
.where("source_type = ?")
.where("user_id = ?")
.order('access_level')
.return_limit('1')
# Q 120 : # GroupMember.where(source_id: self_and_ancestors_ids, user_id: user.id).order(:access_level).last
Query(GroupMember)
.where("source_id IN (?, ?)")
.where("source_type = ?")
.where("user_id = ?")
.order('access_level')
.return_limit('1')
# Q 122 : # Issue.find(params[:ids])
Query(Issue)
.where("id = ?")
# Q 123 : # Issue.find_by(project_id: project.id, iid: iid)
Query(Issue)
.where("project_id = ?")
.where("iid = ?")
# Q 124 : # Issue.of_milestones(milestone).includes(:project, :assignees, :labels)
Query(Issue)
.includes('project')
.includes('assignees')
# Q 125 : # Issue.select(:id, :author_id).where(confidential: true, project_id: project_id)
Query(Issue)
.select('id')
.select('author_id')
.where("confidential = ?")
.where("project_id = ?")
# Q 126 : # Issue.where(id: issue_ids).find_each
Query(Issue)
.where("id IN (?, ?)")
# Q 127 : # IssueAssignee.select(:user_id).where(issue_id: issue.id)
Query(IssueAssignee)
.select('user_id')
.where("issue_id = ?")
# Q 128 : # Key.where(id: ids_in_file)
Query(Key)
.where("id = ?")
# Q 129 : # Label.find(params[:id])
Query(Label)
.where("id = ?")
# Q 130 : # Label.joins("INNER JOIN label_links ON label_links.label_id = labels.id AND label_links.target_type = \'Issue\'
#                   INNER JOIN issues ON issues.id = label_links.target_id
#                   INNER JOIN projects ON projects.id = issues.project_id").where("issues.project_id in (?)", project_ids).where("(labels.project_id is not null and labels.project_id != issues.project_id) " "or (labels.group_id is not null and labels.group_id != projects.namespace_id)").select("distinct issues.id")
Query(Label)
.joins('label_links => target => project')
.where('label_links.target.project_id = param[pid]')
.where('project_id != param[pid]')
.select('label_links.target.id')
.distinct('')
# Q 131 : # Label.joins("INNER JOIN label_links ON label_links.label_id = labels.id AND label_links.target_type = \'MergeRequest\'
#                   INNER JOIN merge_requests ON merge_requests.id = label_links.target_id
#                   INNER JOIN projects ON projects.id = merge_requests.target_project_id").where("merge_requests.target_project_id in (?)", project_ids).where("(labels.project_id is not null and labels.project_id != merge_requests.target_project_id) " "or (labels.group_id is not null and labels.group_id != projects.namespace_id)").select("distinct merge_requests.id")
Query(Label)
.joins('label_links => target => project')
.where('label_links.target.project_id = param[pid]')
.where('project_id != param[pid]')
.select('label_links.target.id')
# Q 132 : # Label.joins(:label_links).where("label_links.target_id" => issues_visible_to_user(user).select(:id), "label_links.target_type" => "Issue").distinct
Query(Label)
.joins('label_links')
.where("label_links.target_id = ?")
.where("label_links.target_type = ?")
.distinct('')
# Q 133 : # Label.select(LabelPriority.arel_table[:priority].minimum).left_join_priorities.joins(:label_links).where("label_priorities.project_id = #{
# project_column}").where("label_links.target_id = #{
# target_column}").reorder(nil)
Query(Label)
.joins('label_links')
.where('label_links.target_id = ?')
.left_outer_joins('priorities')
.where('priorities.project_id = ?')
# Q 134 : # Label.where("(type = 'GroupLabel' and group_id in (?)) or (type = 'ProjectLabel' and id = ?)", project_group_ids(project_id), project_id)
Query(Label)
.where("(type = 'GroupLabel') AND (group_id IN (?, ?))")
.pred_or("(type = 'ProjectLabel') AND (group_id IN (?, ?))")
# Q 135 : # LabelLink.select("label_id, labels.title as title, labels.color as color, label_links.id as label_link_id").joins("INNER JOIN labels ON labels.id = label_links.label_id").where(target_type: resource.class.name.demodulize, target_id: resource.id).where("labels.id not in (?)", local_labels.select(:id))
Query(LabelLink)
.joins("label")
.select('label_id, label.title, label.color')
.where("target_type = ?")
.where("target_id = ?")
# Q 136 : # LfsObject.find_by(oid: oid, size: size)
Query(LfsObject)
.where("oid = ?")
.where("size = ?")
# Q 137 : # LfsObject.find_by_oid(blob.lfs_oid)
Query(LfsObject)
.where("oid = ?")
# Q 138 : # LfsObject.find_by_oid(oid)
Query(LfsObject)
.where("oid = ?")
# Q 139 : # LfsObjectsProject.select("lfs_objects.oid, array_agg(distinct lfs_objects_projects.repository_type) as repository_types").joins(:lfs_object).where(project: project, lfs_object: lfs_objects_batch).group("lfs_objects.oid")
Query(LfsObjectsProject)
.joins('lfs_object')
.where("project = ?")
.where("lfs_object.id IN (?, ?)")
.select('lfs_object.oid')
.group('lfs_object.oid, id')
# Q 140 : # List.find(issue_params[:list_id])
Query(List)
.where("id = ?")
# Q 141 : # ListUserPreference.where(list_id: list_ids.uniq, user_id: user_ids.uniq).find_each
Query(ListUserPreference)
.where("list_id IN (?, ?)")
.where("user_id IN (?, ?)")
# Q 142 : # Member.find_by_invite_token(@token)
Query(Member)
.where("invite_token = ?")
# Q 143 : # Member.on_project_and_ancestors(project).select(:user_id)
Query(Member)
.where("source_id IN (?, ?)")
.select('user_id')
# Q 144 : # Member.where(invite_email: verified_emails).invite
Query(Member)
.where("invite_email IN (?, ?)")
# Q 145 : # MergeRequest.except(:order, :where).select(1).where("merge_requests.source_project_id = events.project_id").where("merge_requests.source_branch = push_event_payloads.ref").with_state(:opened)
Query(MergeRequest)
.where('source_project_id = ?')
.where('source_branch = ?')
# Q 146 : # MergeRequest.find(closed_via[:id]).present
Query(MergeRequest)
.where("id = ?")
# Q 147 : # MergeRequest.find_by(target_project_id: project.id, iid: gh_issue.number)
Query(MergeRequest)
.where("target_project_id = ?")
.where("iid = ?")
# Q 148 : # MergeRequest.find_by(target_project_id: project.id, iid: iid)
Query(MergeRequest)
.where("target_project_id = ?")
.where("iid = ?")
# Q 149 : # MergeRequest.includes(:latest_merge_request_diff).where(source_branch: ref, source_project: pipeline.project).reorder(iid: :desc)
Query(MergeRequest)
.includes('latest_merge_request_diff')
.where("source_branch = ?")
.where("source_project = ?")
.order('iid')
# Q 150 : # MergeRequest.of_milestones(milestone).includes(:target_project, :assignee, :labels)
Query(MergeRequest)
.where('milestone_id = ?')
.includes('target_project')
# Q 151 : # MergeRequest.where("id = ? AND COALESCE(latest_merge_request_diff_id, 0) < ?", self.merge_request_id, self.id).update_all(latest_merge_request_diff_id: self.id)
Query(MergeRequest)
.where('id = ?')
# Q 152 : # MergeRequest.where(id: from_id..to_id, state: "opened", merge_status: "can_be_merged")
Query(MergeRequest)
.where("id IN (?, ?)")
.where("state = 'opened'")
.where("merge_status = 'can_be_merged'")
# Q 153 : # MergeRequest.where(id: merge_request_id)
Query(MergeRequest)
.where("id = ?")
# Q 154 : # MergeRequest.where(id: merge_request_id).limit(1).pluck(:latest_merge_request_diff_id).first
Query(MergeRequest)
.where("id = ?")
.select('latest_merge_request_diff_id')
.return_limit('1')
# Q 155 : # MergeRequest.where(id: mr_ids).find_each
Query(MergeRequest)
.where("id = ?")
# Q 156 : # MergeRequest.where(merge_request_assignees_not_exists_clause).where(id: from_id..to_id).where("assignee_id IS NOT NULL").select(:id, :assignee_id).to_sql
Query(MergeRequest)
.where("id > ?")
.where("id < ?")
.where('assignee_id = 0')
.select('id, assignee_id')
# Q 157 : # MergeRequest.where(source_project_id: project_id, source_branch: ref)
Query(MergeRequest)
.where("source_project_id = ?")
.where("source_branch = ?")
# Q 158 : # MergeRequest.where(target_project: projects)
Query(MergeRequest)
.where("target_project = ?")
# Q 159 : # MergeRequestDiff.where(id: start_id..stop_id).where(commits_count: nil).update_all(update)
Query(MergeRequestDiff)
.where("id > ?")
.where("id < ?")
.where("commits_count = 0")
# Q 160 : # MergeRequestDiffCommit.where(merge_request_diff: merge_request_diffs.recent).limit(10_000)
Query(MergeRequestDiffCommit)
.where("merge_request_diff = ?")
.return_limit('10')
# Q 161 : # MergeRequestDiffFile.where(merge_request_diff_id: id).delete_all
Query(MergeRequestDiffFile)
.where("merge_request_diff_id = ?")
# Q 162 : # Milestone.for_projects_and_groups([project_id], [project.group.id])
Query(Milestone)
.where("project_id IN (?, ?)")
.pred_or("group_id IN (?, ?)")
# Q 163 : # Milestone.for_projects_and_groups(group.projects.select(:id), [group.id])
Query(Milestone)
.where("project_id IN (?, ?)")
.pred_or("group_id IN (?, ?)")
# Q 164 : # Milestone.for_projects_and_groups(projects, groups).reorder(nil).group(:state).count
Query(Milestone)
.where("project_id IN (?, ?)")
.pred_or("group_id IN (?, ?)")
.group('state')
# Q 165 : # Milestone.of_groups(group).count_by_state
Query(Milestone)
.where("project_id IN (?, ?)")
.pred_or("group_id IN (?, ?)")
# Q 166 : # Milestone.of_groups(groups.select(:id)).reorder_by_due_date_asc.order_by_name_asc
Query(Milestone)
.where("project_id IN (?, ?)")
# Q 167 : # Milestone.of_projects(projects).reorder_by_due_date_asc.order_by_name_asc
Query(Milestone)
.where("project_id IN (?, ?)")
# Q 168 : # Milestone.of_projects(projects).where(title: title)
Query(Milestone)
.where("project_id IN (?, ?)")
.where("title = ?")
# Q 169 : # Milestone.of_projects(projects).where(title: title)
Query(Milestone)
.where("project_id IN (?, ?)")
.where("title = ?")
# Q 170 : # Milestone.of_projects(projects.reorder(nil)).count_by_state
Query(Milestone)
.where("project_id IN (?, ?)")
.group('state')
# Q 171 : # Namespace.eager_load(:owner, :route).where_full_path_in(usernames).index_by(&:full_path).transform_keys(&:downcase)
Query(Namespace)
.includes('owner')
.where('path = ?')
# Q 172 : # Namespace.find(extra_group).kind
Query(Namespace)
.where("id = ?")
# Q 173 : # Namespace.find(ids.last)
Query(Namespace)
.where("id = ?")
# Q 174 : # Namespace.find(params[:namespace_key])
Query(Namespace)
.where("id = ?")
# Q 175 : # Namespace.find(parent_id_before_last_save)
Query(Namespace)
.where("id = ?")
# Q 176 : # Namespace.find(project_params[:namespace_id])
Query(Namespace)
.where("id = ?")
# Q 177 : # Namespace.find_by(id: id)
Query(Namespace)
.where("id = ?")
# Q 178 : # Namespace.find_by(id: params[:namespace_id])
Query(Namespace)
.where("id = ?")
# Q 179 : # Namespace.find_by(id: params[:new_namespace_id])
Query(Namespace)
.where("id = ?")
# Q 180 : # Namespace.find_by(id: params[:new_namespace_id])
Query(Namespace)
.where("id = ?")
# Q 181 : # Namespace.find_by_full_path(id)
Query(Namespace)
.where("full_path = ?")
# Q 182 : # Namespace.find_by_full_path(name)
Query(Namespace)
.where("full_path = ?")
# Q 183 : # Namespace.find_by_full_path(namespace_path)
Query(Namespace)
.where("full_path = ?")
# Q 184 : # Namespace.find_by_path_or_name(params[:username])
Query(Namespace)
.where("path = ?")
.pred_or("name = ?")
# Q 185 : # Namespace.find_by_path_or_name(s)
Query(Namespace)
.where("path = ?")
.pred_or("name = ?")
# Q 186 : # Namespace.for_user.find_by_full_path(path, follow_redirects: follow_redirects)
Query(Namespace)
.where("full_path = ?")
# Q 187 : # Namespace.unscoped.select([alias_as_column(projects[:id], "project_id"), cte_alias[:access_level]]).from(cte_alias).joins(:projects)
# Q 189 : # Namespace.where(id: descendants.select(:id)).update_all(share_with_group_lock: true)
Query(Namespace)
.where("id = ?")
# Q 190 : # Namespace.where(id: namespace_ids)
Query(Namespace)
.where("id = ?")
# Q 191 : # Namespace.where(parent: nil).all.pluck(:path)
Query(Namespace)
.where("parent = 0")
.select('path')
# Q 192 : # Namespace.where(type: "Group", id: Label.where(type: "GroupLabel").select("distinct group_id")).where(id: start_id..stop_id).pluck(:id)
Query(Namespace)
.where("type = ?")
.where("id < ?")
.where("id > ?")
.select('id')
# Q 193 : # Namespace.where(type: "Group", parent_id: ids).pluck(:id)
Query(Namespace)
.where("type = ?")
.where("parent_id = ?")
.select('id')
# Q 194 : # Note.find_by(id: upload.model_id)
Query(Note)
.where("id = ?")
# Q 195 : # Note.from_union([notes, commit_notes], remove_duplicates: false).includes(:noteable)
Query(Note)
.includes('noteable')
# Q 196 : # Note.user.where(project_id: [source_project_id, target_project_id]).for_commit_id(commit_ids)
Query(Note)
.where("project_id IN (?, ?)")
.where("commit_id IN (?, ?)")
# Q 197 : # Note.where(discussion_id: discussion_ids).fresh.to_a.group_by(&:discussion_id)
Query(Note)
.where("discussion_id = ?")
# Q 198 : # Note.where(id: notes.map(&:id))
Query(Note)
.where("id = ?")
# Q 199 : # Note.where(noteable_type: "Epic").where(discussion_id: discussion_ids).update_all("discussion_id=MD5(discussion_id)||substring(discussion_id from 1 for 8)")
Query(Note)
.where("noteable_type = ?")
.where("discussion_id = ?")
# Q 200 : # NoteDiffFile.joins(:diff_note).merge(notes.or(commit_notes)).includes(diff_note: :project)
Query(NoteDiffFile)
.joins('diff_note')
.where('diff_note.type = ?')
# Q 201 : # NotificationSetting.where(source_type: source_type, source_id: self_and_ancestors_ids)
Query(NotificationSetting)
.where("source_type = ?")
.where("source_id = ?")
# Q 203 : # PagesDomain.where(id: start_id..stop_id).find_each
Query(PagesDomain)
.where("id < ?")
.where("id > ?")
# Q 204 : # PagesDomainAcmeOrder.find_by_domain_and_token(params[:domain], params[:token])
Query(PagesDomainAcmeOrder)
.joins("pages_domain")
.where("pages_domain.id = ?")
.where("pages_domain.domain = ?")
# Q 205 : # PersonalAccessToken.find_by_token(token)
# Q 206 : # PersonalSnippet.find_by(id: params[:snippet_id])
Query(PersonalSnippet)
.where("id = ?")
# Q 207 : # PersonalSnippet.inc_relations_for_view.find_by(id: params[:id])
Query(PersonalSnippet)
.where("id = ?")
# Q 208 : # PoolRepository.includes(:source_project).find_each
Query(PoolRepository)
.includes('source_project')
# Q 211 : # Project.find(@project_id)
Query(Project)
.where("id = ?")
# Q 212 : # Project.find(data[:project][:id])
Query(Project)
.where("id = ?")
# Q 213 : # Project.find(issue_params[:project_id])
Query(Project)
.where("id = ?")
# Q 214 : # Project.find(note_project_id)
Query(Project)
.where("id = ?")
# Q 215 : # Project.find(params[:confidential_issue_project_id])
Query(Project)
.where("id = ?")
# Q 216 : # Project.find(params[:id])
Query(Project)
.where("id = ?")
# Q 217 : # Project.find(params[:move_to_project_id])
Query(Project)
.where("id = ?")
# Q 218 : # Project.find(params[:project_id])
Query(Project)
.where("id = ?")
# Q 219 : # Project.find(params[:source_project_id])
Query(Project)
.where("id = ?")
# Q 220 : # Project.find(project_id)
Query(Project)
.where("id = ?")
# Q 221 : # Project.find(project_id)
Query(Project)
.where("id = ?")
# Q 222 : # Project.find(project_id)
Query(Project)
.where("id = ?")
# Q 223 : # Project.find(project_id).namespace_id
Query(Project)
.where("id = ?")
.select('namespace_id')
# Q 224 : # Project.find_by(id: params[:project_id])
Query(Project)
.where("id = ?")
# Q 225 : # Project.find_by(id: project_id)
Query(Project)
.where("id = ?")
# Q 226 : # Project.find_by(id: project_id)
Query(Project)
.where("id = ?")
# Q 227 : # Project.find_by_full_path("#{
# namespace}/#{
# id}")
Query(Project)
.where("path = ?")
# Q 228 : # Project.find_by_full_path("#{
# project.namespace.full_path}/#{
# original_path}")
Query(Project)
.where("path = ?")
# Q 229 : # Project.find_by_full_path([params[:namespace_id], "/", params[:id]].join(""))
Query(Project)
.where("path = ?")
# Q 230 : # Project.find_by_full_path([params[:namespace_id], "/", params[:project_id]].join(""))
Query(Project)
.where("path = ?")
# Q 231 : # Project.find_by_full_path(full_path, follow_redirects: request.get?).present?
Query(Project)
.where("path = ?")
# Q 232 : # Project.find_by_path(match[:project_path])
Query(Project)
.where("path = ?")
# Q 233 : # Project.find_by_path(params[:project])
Query(Project)
.where("path = ?")
# Q 234 : # Project.find_by_path(project_path)
Query(Project)
.where("path = ?")
# Q 235 : # Project.find_by_path(project_path)
Query(Project)
.where("path = ?")
# Q 236 : # Project.find_by_path(project_path, follow_redirects: true)
Query(Project)
.where("path = ?")
# Q 237 : # Project.find_by_path(ref)
Query(Project)
.where("path = ?")
# Q 238 : # Project.find_by_id(array[0])
Query(Project)
.where("id = ?")
# Q 239 : # Project.find_by_id(project_id)
Query(Project)
.where("id = ?")
# Q 240 : # Project.find_by_id(project_id)
Query(Project)
.where("id = ?")
# Q 241 : # Project.find_by_id(subject_id)
Query(Project)
.where("id = ?")
# Q 242 : # Project.includes(:parent).where(id: start_id..end_id).each
Query(Project)
.where("id = ?")
# Q 244 : # Project.order_id_desc.without_deleted.with_route.limit(10)
Query(Project)
.where('updated_at = 0')
.return_limit('1')
# Q 245 : # Project.pending_delete.find_by_full_path(full_path)
Query(Project)
.select('pending_delete')
.where("path = ?")
# Q 246 : # Project.public_or_visible_to_user(user).where("projects.id IN (?)", @projects_for_nodes.values.map(&:id)).pluck(:id)
Query(Project)
.where('visibility_level = ?')
.select('id')
# Q 247 : # Project.sorted_by_activity.limit(PROJECTS_LIMIT)
Query(Project)
.return_limit('10')
# Q 248 : # Project.unscoped.find_by(id: project_id)
Query(Project)
.where("id = ?")
# Q 249 : # Project.unscoped.where(id: project_id).where("last_activity_at <= ?", RESET_PROJECT_ACTIVITY_INTERVAL.ago).update_all(last_activity_at: created_at)
Query(Project)
.where('last_activity_at <= ?')
.where("id = ?")
# Q 250 : # Project.unscoped.where(id: project_id).where("last_repository_updated_at < ? OR last_repository_updated_at IS NULL", REPOSITORY_UPDATED_AT_INTERVAL.ago).update_all(last_repository_updated_at: created_at)
Query(Project)
.where("id = ?")
# Q 251 : # Project.where("EXISTS (SELECT 1 FROM todos WHERE todos.project_id = projects.id)").where(id: start_id..stop_id)
Query(Project)
.where("exists(todos, id = ?)")
.where("id < ?")
.where('id > ?')
# Q 252 : # Project.where(id: @contributed_project_ids).with_feature_available_for_user(feature, user).reorder(nil).select(:id)
Query(Project)
.where("id IN (?, ?)")
.select('id')
# Q 253 : # Project.where(id: @project.id)
Query(Project)
.where("id = ?")
# Q 254 : # Project.where(id: events)
Query(Project)
.where("id = ?")
# Q 255 : # Project.where(id: project).select(:id).reorder(nil)
Query(Project)
.where("id = ?")
.select('id')
# Q 256 : # Project.where(id: project_ids).ids_with_issuables_available_for(user)
Query(Project)
.where("id = ?")
# Q 257 : # Project.where(id: start_id..stop_id).with_pages_deployed.includes(:project_feature).find_each
Query(Project)
.where("id = ?")
.includes('project_feature')
# Q 258 : # Project.where(namespace_id: group_ids).select(:id)
Query(Project)
.where("namespace_id = ?")
.select('id')
# Q 259 : # Project.where(namespace_id: namespace_id, path: path_to_check).exists?
Query(Project)
.where("namespace_id = ?")
.where("path = ?")
.return_limit('1')
# Q 260 : # Project.where_full_path_in([full_path]).pluck(:id)
Query(Project)
.where("path IN (?, ?)")
.select('id')
# Q 264 : # ProjectAuthorization.select(:user_id).where(project_id: project_id)
Query(ProjectAuthorization)
.select('user_id')
.where("project_id = ?")
# Q 265 : # ProjectFeature.where(id: start_id..stop_id).joins(:project).where(pages_access_level: pages_access_level).where(projects: { visibility_level: project_visibility_level })
Query(ProjectFeature)
.where("id < ?")
.where("id > ?")
.joins('project')
.where("pages_access_level = ?")
.where("project.visibility_level = ?")
# Q 266 : # ProjectFeature.where(project_id: project_id).each
Query(ProjectFeature)
.where("project_id = ?")
# Q 267 : # ProjectMember.where(source_id: project_ids)
Query(ProjectMember)
.where("source_id = ?")
# Q 268 : # PrometheusMetric.find_by_identifier(:system_metrics_knative_function_invocation_count).to_query_metric.tap
Query(PrometheusMetric)
.where("identifier = ?")
# Q 269 : # Service.services_to_update.where(id: start_id..stop_id).update_all(confidential_note_events: true)
Query(Service)
.where("id < ?")
.where('id > ?')
# Q 270 : # Service.unscoped.where(type: :JiraService, active: true).includes(:jira_tracker_data).find_in_batches(batch_size: BATCH_SIZE)
Query(Service)
.where("type = ?")
.where("active = true")
# Q 271 : # Service.where(id: params[:id], template: true).first
Query(Service)
.where("id = ?")
.where("template = true")
.return_limit('1')
# Q 272 : # Service.where(template: true)
Query(Service)
.where("template = true")
# Q 273 : # SpamLog.find(params[:id])
Query(SpamLog)
.where("id = ?")
# Q 274 : # SpamLog.find(params[:id])
Query(SpamLog)
.where("id = ?")
# Q 275 : # SpamLog.order(id: :desc).page(params[:page])
Query(SpamLog)
.order('id')
# Q 276 : # Stage.find_by(name: self.stage || "test", pipeline_id: self.commit_id, project_id: self.project_id)
# Q 277 : # SystemHook.find(params[:hook_id])
Query(SystemHook)
.where("id = ?")
# Q 278 : # SystemHook.find(params[:id])
Query(SystemHook)
.where("id = ?")
# Q 279 : # Todo.where(project_id: project_id).where("user_id NOT IN (?)", authorized_users(project_id))
Query(Todo)
.where("project_id = ?")
.where("!(user_id IN (?, ?))")
# Q 280 : # Todo.where(target_type: "Issue", target_id: issue.id).where("user_id NOT IN (?)", min_reporters).where("user_id NOT IN (?)", assigned_users)
Query(Todo)
.where("target_type = ?")
.where("target_id = ?")
.where("!(user_id IN (?, ?))")
# Q 281 : # Upload.all.preload(:model)
Query(Upload)
.includes('model')
# Q 282 : # Upload.find_by(model: model, uploader: uploader_class.to_s, path: upload_paths)
Query(Upload)
.joins('model')
.where("model.id = ?")
.where("uploader = ?")
.where("path = ?")
# Q 283 : # Upload.find_by(model: self, path: paths)
Query(Upload)
.joins('model')
.where("model.id = ?")
.where("path = ?")
# Q 284 : # Upload.find_by(model: self, path: paths)
Query(Upload)
.joins('model')
.where("model.id = ?")
.where("path = ?")
# Q 285 : # Upload.find_by(uploader: "FileUploader", path: upload_path)
Query(Upload)
.where("uploader = ?")
.where("path = ?")
# Q 286 : # Upload.joins("          JOIN projects
#   ON (uploads.model_type='Project' AND uploads.model_id=projects.id)
# ").where("projects.storage_version < :version OR projects.storage_version IS NULL", version: Project::HASHED_STORAGE_FEATURES[:attachments])
Query(Upload)
.joins('model')
.where('model.storage_version < ?')
# Q 287 : # Upload.where("lower(path) like ? or lower(path) like ? or lower(path) like ?", "%.jpg", "%.jpeg", "%.tiff")
Query(Upload)
.where("path = ?")
# Q 288 : # Upload.where(id: start_id..end_id, uploader: "AttachmentUploader", model_type: "Note").find_each
Query(Upload)
.where("id = ?")
.where("uploader = ?")
.where("model_type = ?")
# Q 289 : # Upload.where(store: ObjectStorage::Store::REMOTE, path: file_paths).pluck(:path)
Query(Upload)
.where("store = ?")
.where("path = ?")
.select('path')
# Q 290 : # Upload.where(store: store_type, uploader: @uploader_class.to_s, model_type: @model_class.base_class.sti_name)
Query(Upload)
.where("store = ?")
.where("uploader = ?")
.where("model_type = ?")
# Q 291 : # Upload.where(uploader: AvatarUploader.name, path: paths).find_each
Query(Upload)
.where("uploader = ?")
.where("path = ?")
# Q 292 : # User.admins.last
Query(User)
.where('admin = true')
.return_limit('1')
# Q 293 : # User.admins.order_id_asc.first
Query(User)
.where('admin = true')
.return_limit('1')
# Q 294 : # User.by_any_email(email).pluck(:id).first
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
.select('id')
.return_limit('1')
# Q 295 : # User.by_any_email(emails).includes(:emails)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
.includes('emails')
# Q 296 : # User.find(@author_id)
Query(User)
.where("id = ?")
# Q 297 : # User.find(options[:user_id])
Query(User)
.where("id = ?")
# Q 298 : # User.find(session[:impersonator_id])
Query(User)
.where("id = ?")
# Q 299 : # User.find(session[:otp_user_id])
Query(User)
.where("id = ?")
# Q 300 : # User.find_by!(username: params[:user_id])
Query(User)
.where("username = ?")
# Q 301 : # User.find_by!(username: params[:user_id])
Query(User)
.where("username = ?")
# Q 302 : # User.find_by!(username: params[:user_id])
Query(User)
.where("username = ?")
# Q 303 : # User.find_by(email: user)
Query(User)
.where("email = ?")
# Q 304 : # User.find_by(id: created_by_id)
Query(User)
.where("id = ?")
# Q 305 : # User.find_by(id: user_id)
Query(User)
.where("id = ?")
# Q 306 : # User.find_by(id: id)
Query(User)
.where("id = ?")
# Q 307 : # User.find_by(id: params[:user_id])
Query(User)
.where("id = ?")
# Q 308 : # User.find_by(id: token.resource_owner_id)
Query(User)
.where("id = ?")
# Q 309 : # User.find_by(id: user)
Query(User)
.where("id = ?")
# Q 310 : # User.find_by(id: user_hash["gitlab_user"])
Query(User)
.where("id = ?")
# Q 311 : # User.find_by(id: user_id)
Query(User)
.where("id = ?")
# Q 312 : # User.find_by(id: user_id)
Query(User)
.where("id = ?")
# Q 313 : # User.find_by(incoming_email_token: incoming_email_token)
Query(User)
.where("incoming_email_token = ?")
# Q 314 : # User.find_by(incoming_email_token: incoming_email_token)
Query(User)
.where("incoming_email_token = ?")
# Q 315 : # User.find_by_any_email(committer_email)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
# Q 316 : # User.find_by_any_email(email)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
# Q 317 : # User.find_by_any_email(email)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
# Q 318 : # User.find_by_any_email(email)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
# Q 319 : # User.find_by_any_email(email).try(:id)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
.select('id')
# Q 320 : # User.find_by_any_email(email, confirmed: true)
Query(User)
.where('email = param[email]')
.pred_or('exists(emails, email = param[email])')
# Q 321 : # User.find_by_email(s)
Query(User)
.where("email = ?")
# Q 322 : # User.find_by_feed_token(token)
Query(User)
.where("feed_token = ?")
# Q 323 : # User.find_by_full_path(full_path, follow_redirects: request.get?).present?
# Q 324 : # User.find_by_id(params[:assignee_id])
Query(User)
.where("id = ?")
# Q 325 : # User.find_by_id(params[:author_id])
Query(User)
.where("id = ?")
# Q 326 : # User.find_by_ssh_key_id(key_id)
# Q 327 : # User.find_by_static_object_token(token)
Query(User)
.where("static_object_token = ?")
# Q 328 : # User.find_by_username(s)
Query(User)
.where("username = ?")
# Q 329 : # User.for_github_id(id).pluck(:id).first
Query(User)
.select('id')
.return_limit('1')
# Q 330 : # User.joins(:group_members).where(members: { source_id: ids }).to_a
Query(User)
.joins('group_members')
.where("group_members.source_id = ?")
# Q 331 : # User.joins(:identities).find_by("identities.extern_uid = ? AND identities.provider = 'gitlab'", gitlab_id.to_s)
Query(User)
.joins('identities')
# Q 332 : # User.joins(:issue_assignees).where("issue_assignees.issue_id" => issues_visible_to_user(user).select(:id)).distinct
Query(User)
.joins('issue_assignees')
.where("issue_assignees.issue_id = ?")
.distinct('')
# Q 333 : # User.joins(assigned_issues: :milestone).where("milestones.id = ?", id).distinct
Query(User)
.distinct('')
# Q 334 : # User.joins(projects: :group).where(namespaces: { id: self_and_descendants.select(:id) })
Query(User)
.joins('projects => group')
.where("projects.namespace_id IN (?, ?)")
.where("id = ?")
# Q 335 : # User.select(:id).joins(:identities).find_by("identities.extern_uid = ? AND identities.provider = 'bitbucket'", username).try(:id)
Query(User)
.joins('identities')
.where("identities.extern_uid = ?")
.where("identities.provider = 'bitbucket'")
.select('id')
# Q 336 : # User.select(:id).joins(:identities).where(identities[:provider].eq(:github).and(identities[:extern_uid].eq(id))).first.try(:id)
Query(User)
.joins('identities')
.where("identities.extern_uid = ?")
.where("identities.provider = 'bitbucket'")
.return_limit('1')
.select('id')
# Q 337 : # User.where(id: deprecated_assignee_id)
Query(User)
.where("id = ?")
# Q 338 : # User.where(id: members_with_descendants.select(:user_id)).reorder(nil)
Query(User)
.where("id = ?")
# Q 339 : # User.where(id: members_with_parents.select(:user_id)).reorder(nil)
Query(User)
.where("id = ?")
# Q 340 : # User.where(id: relation)
Query(User)
# Q 341 : # User.where(id: row["user_id"]).update_all(encrypted_otp_secret: row["old_value"])
Query(User)
.where("id = ?")
# Q 342 : # User.where(id: user[:id]).update_all(encrypted_otp_secret: new_value)
Query(User)
.where("id = ?")
# Q 343 : # User.where(private_profile: nil, id: start_id..stop_id).update_all(private_profile: false)
Query(User)
.where("private_profile = ?")
.where("id = ?")
# Q 344 : # User.where(reset_password_token: reset_password_token).first_or_initialize
Query(User)
.where("reset_password_token = ?")
# Q 345 : # WebHook.hooks_to_update.where(id: start_id..stop_id).update_all(confidential_note_events: true)
Query(WebHook)
.where("id = ?")
# Q 346 : # active.where("access_level > 0")
Query(Member)
.where("state = 'active'")
.where('access_level > 0')
# Q 347 : # active.where("milestones.start_date <= CURRENT_DATE")
Query(Milestone)
.where("state = 'active'")
.where('start_date < ?')
# Q 348 : # active.where("next_run_at < ?", Time.now)
Query(CiPipelineSchedule)
.where('active = true')
.where('next_run_at < ?')
# Q 349 : # active.where(access_level: DEVELOPER)
Query(Member)
.where("state = 'active'")
.where("access_level = ?")
# Q 350 : # active.where(access_level: GUEST)
Query(Member)
.where("state = 'active'")
.where("access_level = ?")
# Q 351 : # active.where(access_level: MAINTAINER)
Query(Member)
.where("state = 'active'")
.where("access_level = ?")
# Q 352 : # active.where(access_level: OWNER)
Query(Member)
.where("state = 'active'")
.where("access_level = ?")
# Q 353 : # active.where(access_level: REPORTER)
Query(Member)
.where("state = 'active'")
.where("access_level = ?")
# Q 354 : # active.where(access_level: [OWNER, MAINTAINER])
Query(Member)
.where("state = 'active'")
.where("access_level = ?")
# Q 355 : # authorized_projects(Gitlab::Access::REPORTER).where(id: projects)
Query(User)
.where("id = ?")
# Q 356 : # authorized_users(project_id).select(:user_id).where("access_level >= ?", 20)
# Q 357 : # award_emoji.group_by(&:name)
Query(AwardEmoji)
.group('name')
# Q 358 : # base.pluck(:id)
# Q 359 : # board.lists.destroyable.find(params[:id])
Query(List)
.where("board_id = ?")
.where("id = ?")
# Q 360 : # board.lists.find(params[:id])
Query(List)
.where("board_id = ?")
.where("id = ?")
# Q 361 : # board.lists.movable.preload_associations
Query(List)
.where("type IN (?, ?)")
.where("board_id = ?")
# Q 362 : # boards.find(params[:id])
Query(Board)
.where("id = ?")
# Q 363 : # build_ports(image).select(&:valid?)
# Q 365 : # builds.where(status: available_statuses && scope)
Query(CiBuild)
.where("status = ?")
# Q 366 : # by_user_group(user, group).order(updated_at: :desc)
Query(BoardGroupRecentVisit)
.order('updated_at')
# Q 367 : # by_user_project(user, project).order(updated_at: :desc)
Query(BoardProjectRecentVisit)
.order('updated_at')
# Q 368 : # by_username(username).take
Query(User)
.where('username = ?')
.return_limit('1')
# Q 369 : # by_username(username).take!
Query(User)
.where('username = ?')
# Q 370 : # canonical(issue).take
# Q 372 : # ci_services.reorder(nil).find_by(active: true)
Query(CiService)
.where("active = ?")
# Q 373 : # closing_merge_requests(ids, user).group(:issue_id).pluck("issue_id", "COUNT(*) as count")
Query(MergeRequestsClosingIssues)
.group('issue_id')
# Q 374 : # commits.group_by(&:author_email).map
# Q 375 : # commits.without_merge_commits.reverse.find(&:description?).safe_message
Query(Commit)
.where("id = ?")
# Q 376 : # user.callouts.find_by(feature_name: UserCallout.feature_names[feature_name])
Query(UserCallout)
.where("user_id = ?")
.where("feature_name = ?")
# Q 377 : # user.created_projects.where(import_type: import_type).includes(:import_state)
Query(Project)
.where("creator_id = ?")
.where("import_type = ?")
.includes('import_state')
# Q 378 : # user.created_projects.where(import_type: import_type, import_source: import_sources).includes(:import_state)
Query(Project)
.where("creator_id = ?")
.where("import_type = ?")
.where("import_source = ?")
.includes('import_state')
# Q 379 : # user.emails.find(params[:id])
Query(Email)
.where("user_id = ?")
.where("id = ?")
# Q 380 : # user.expanded_groups_requiring_two_factor_authentication.reorder(name: :asc)
Query(User)
.order('name')
# Q 381 : # user.gpg_keys.find(params[:id])
Query(GpgKey)
.where("user_id = ?")
.where("id = ?")
# Q 382 : # user.gpg_keys.select(&:persisted?)
Query(GpgKey)
.where("user_id = ?")
# Q 383 : # user.identities.find_by(provider: provider)
Query(Identity)
.where("user_id = ?")
.where("provider = ?")
# Q 384 : # user.keys.find(params[:id])
Query(Key)
.where("user_id = ?")
.where("id = ?")
# Q 385 : # user.keys.find(params[:id])
Query(Key)
.where("user_id = ?")
.where("id = ?")
# Q 386 : # user.keys.select(&:persisted?)
Query(Key)
.where("user_id = ?")
# Q 387 : # user.notification_settings.find(params[:id])
Query(NotificationSetting)
.where("user_id = ?")
.where("id = ?")
# Q 388 : # user.notification_settings.for_groups.order(:id)
Query(NotificationSetting)
.where("user_id = ?")
.order('id')
# Q 389 : # user.notification_settings.for_projects.order(:id)
Query(NotificationSetting)
.where("user_id = ?")
.order('id')
# Q 390 : # user.oauth_applications.find(params[:id])
# Q 391 : # user.u2f_registrations.find(params[:id])
Query(U2fRegistration)
.where("user_id = ?")
.where("id = ?")
# Q 392 : # deploy_key.projects.find
Query(Project)
.joins("deploy_keys")
.where("deploy_keys.id = ?")
.where("id = ?")
# Q 393 : # deploy_keys.find(params[:id])
Query(DeployKey)
.where("id = ?")
# Q 394 : # deploy_keys_projects.find_by(project: project)
Query(DeployKeysProject)
.where("project = ?")
# Q 395 : # deployment.try(:last?)
Query(Deployment)
.return_limit(1)
# Q 396 : # deployments.find_by(iid: deployment_iid)
Query(Deployment)
.where("iid = ?")
# Q 397 : # deployments.where("created_at > ?", params[:after].to_time)
Query(Deployment)
.where('created_at > ?')
# Q 398 : # deployments.where("deployments.created_at > ?", from)
Query(Deployment)
.where('created_at > ?')
# Q 399 : # deployments.where(projects: { id: options[:projects] })
Query(Deployment)
.where("id = ?")
# Q 400 : # emails.confirmed.where(email: self.email).any?
Query(Email)
.where("email = ?")
# Q 401 : # emails.find
Query(Email)
.where("id = ?")
# Q 402 : # emails.find_by(email: email)
Query(Email)
.where("email = ?")
# Q 403 : # emails.map { |email|
#   
#   user_id_for_email(email)
# }.compact.uniq
Query(Email)
.joins('user')
.where('user.id = ?')
.distinct('')
# Q 404 : # environment.deployments.find_successful_deployment!(params[:id])
Query(Deployment)
.where("environment_id = ?")
# Q 405 : # environment.deployments.order(id: :desc).page(params[:page])
Query(Deployment)
.where("environment_id = ?")
.order('id')
# Q 406 : # environment.deployments.reorder(created_at: :desc)
Query(Deployment)
.where("environment_id = ?")
.order('created_at')
# Q 407 : # environment.last_deployment
Query(Deployment)
.where("id = ?")
# Q 408 : # environment.terminals.try(:first)
Query(Environment)
.return_limit(1)
# Q 409 : # environments.with_state(:available).reorder(production_first).first
Query(Environment)
.where("state = 2")
.return_limit('1')
# Q 410 : # events.find
Query(Event)
.where("id = ?")
# Q 411 : # events.where(action: Event::COMMENTED)
Query(Event)
.where("action = ?")
# Q 412 : # events.where(action: Event::MERGED)
Query(Event)
.where("action = ?")
# Q 413 : # events.where(action: Event::PUSHED)
Query(Event)
.where("action = ?")
# Q 414 : # events.where(action: [Event::CREATED, Event::UPDATED, Event::CLOSED, Event::REOPENED], target_type: "Issue")
Query(Event)
.where("action = ?")
.where("target_type = ?")
# Q 415 : # events.where(action: [Event::JOINED, Event::LEFT, Event::EXPIRED])
Query(Event)
.where("action = ?")
# Q 416 : # find(ids)
Query(Deployment)
.where("id = ?")
# Q 417 : # find(repo)
Query(Commit)
.where("id = ?")
# Q 418 : # find_by(id: user_id)
Query(User)
.where("id = ?")
# Q 419 : # find_by(invite_token: invite_token)
Query(Member)
.where("invite_token = ?")
# Q 420 : # find_by(reply_key: reply_key)
Query(SentNotification)
.where("reply_key = ?")
# Q 421 : # find_by(start_commit_sha: diff_refs.start_sha, head_commit_sha: diff_refs.head_sha, base_commit_sha: diff_refs.base_sha)
Query(MergeRequestDiff)
.where("start_commit_sha = ?")
.where("head_commit_sha = ?")
.where("base_commit_sha = ?")
# Q 422 : # find_by(template: true)
Query(Service)
.where("template = ?")
# Q 423 : # finished.where("finished_at < ?", date)
Query(CiBuild)
.where("finished_at < ?")
# Q 424 : # for_sha(shas).group(:sha).select("max(id)")
Query(CiPipeline)
.where("sha IN (?, ?)")
.group('sha')
.select('id')
# Q 425 : # from_union([with_issues_enabled, with_merge_requests_enabled]).select(:id)
Query(Project)
.select('id')
# Q 427 : # gpg_key.subkeys.pluck(:id)
Query(GpgKeySubkey)
.where("gpg_key_id = ?")
.select('id')
# Q 428 : # group(:target_branch).select(:target_branch).reorder("MAX(merge_requests.updated_at) DESC").limit(limit).pluck(:target_branch)
Query(MergeRequest)
.group('target_branch')
.order('updated_at')
.return_limit('10')
.select('target_branch')
# Q 429 : # group.all_projects.where(import_type: "manifest").where(creator_id: user).includes(:import_state)
Query(Project)
.where('group_id = ?')
.where("import_type = ?")
.where("creator_id = ?")
# Q 430 : # group.ancestors.find
Query(Group)
.where('parent_id = ?')
.where("id = ?")
# Q 431 : # group.members.collect(&:user)
Query(Member)
.joins('source')
.where('source.id = ?')
.select('user_id')
# Q 432 : # group.members.find_by(user_id: user_id)
Query(Member)
.joins('source')
.where('source.id = ?')
.where("user_id = ?")
# Q 433 : # group.milestones.find_by_iid(params[:id])
Query(Milestone)
.where("iid = ?")
# Q 434 : # group.projects.reject(&:lfs_enabled?).size
Query(Project)
.joins("group")
.where("group.id = ?")
.where('lfs_enabled = true')
# Q 435 : # group.projects.select(&:lfs_enabled?).size
Query(Project)
.joins("group")
.where('lfs_enabled = true')
# Q 436 : # group.try(:avatar_url)
# Q 438 : # group.variables.find_by(key: "AUTO_DEVOPS_DOMAIN").value.presence
# Q 439 : # group_members.find
Query(GroupMember)
.where("id = ?")
# Q 440 : # group_members.find_by(user_id: user)
Query(GroupMember)
.where("user_id = ?")
# Q 441 : # group_members.where(source: group_ids).group(:source_id).maximum(:access_level)
Query(GroupMember)
.where("source = ?")
.where("id = ?")
# Q 443 : # groups.pluck(:id)
Query(Group)
.select('id')
# Q 445 : # groups.where(parent_id: params[:parent_id]).page(params[:page])
Query(Group)
.where("parent_id = ?")
# Q 446 : # identities.find
Query(Identity)
.where("id = ?")
# Q 447 : # identities.find
Query(Identity)
.where("id = ?")
# Q 448 : # includes(:author)
Query(Snippet)
.includes('author')
# Q 449 : # includes(:author, :project, project: [:project_feature, :import_data, :namespace]).preload(:target, :push_event_payload)
Query(Event)
.includes('author')
.includes('project')
.includes('target')
.includes('push_event_payload')
# Q 450 : # includes(:label, :user)
Query(ResourceLabelEvent)
.includes('label')
.includes('user')
# Q 451 : # includes(:project).references(:projects).where(source_type: "Project").where.not(projects: { id: nil, pending_delete: true })
Query(NotificationSetting)
.includes('project')
.where("source_type = ?")
.where("id = ?")
# Q 452 : # includes(:statistics)
Query(Project)
.includes('statistics')
# Q 453 : # includes(:subkeys)
Query(GpgKey)
.includes('subkeys')
# Q 457 : # issues.preload(:milestone, :assignees, project: [:route, { namespace: [:route] }], labels: [:priorities], notes: [:award_emoji, :author])
Query(Issue)
.includes('assignees')
# Q 458 : # issues.where(project_id: project_ids_relation)
Query(Issue)
.where("project_id = ?")
# Q 459 : # issues.where(projects: { id: options[:projects] })
Query(Issue)
.where("project_id IN (?, ?)")
# Q 461 : # joins("INNER JOIN namespaces project_namespace ON project_namespace.id = projects.namespace_id").where("project_namespace.share_with_group_lock = ?", false).select("projects.id AS project_id, LEAST(project_group_links.group_access, members.access_level) AS access_level")
# Q 462 : # joins("INNER JOIN project_mirror_data import_state ON import_state.project_id = projects.id")
Query(Project)
.joins('namespace')
.where("namespace.share_with_group_lock = false")
# Q 463 : # joins("INNER JOIN projects ON projects.id = members.source_id").where("projects.namespace_id in (?)", groups.select(:id))
Query(ProjectMember)
.joins('project')
.where("project.namespace_id IN (?, ?)")
# Q 464 : # joins("INNER JOIN routes ON routes.source_id = projects.id AND routes.source_type = 'Project'").where(where)
# Q 465 : # joins("INNER JOIN routes rs ON rs.source_id = projects.id AND rs.source_type = 'Project'").where("rs.path LIKE ?", "#{
# sanitize_sql_like(path)}/%")
# Q 468 : # joins("LEFT JOIN project_features ON projects.id = project_features.project_id")
Query(Project)
.left_outer_joins('project_feature')
# Q 469 : # joins("LEFT JOIN project_statistics ps ON ps.namespace_id = namespaces.id").group("namespaces.id").select("namespaces.*", "COALESCE(SUM(ps.storage_size), 0) AS storage_size", "COALESCE(SUM(ps.repository_size), 0) AS repository_size", "COALESCE(SUM(ps.wiki_size), 0) AS wiki_size", "COALESCE(SUM(ps.lfs_objects_size), 0) AS lfs_objects_size", "COALESCE(SUM(ps.build_artifacts_size), 0) AS build_artifacts_size", "COALESCE(SUM(ps.packages_size), 0) AS packages_size")
Query(Namespace)
.left_outer_joins('project_statistics => project')
.select("project_statistics.type, project_statistics.project.id")
# Q 471 : # joins(:ci_cd_settings).where(project_ci_cd_settings: { group_runners_enabled: true })
Query(Project)
.joins('ci_cd_settings')
.where("ci_cd_settings.group_runners_enabled = ?")
# Q 472 : # joins(:deploy_keys_projects).where("deploy_keys_projects.project_id in (?)", projects)
Query(DeployKey)
.joins('deploy_keys_projects')
.where('deploy_keys_projects.id IN (?, ?)')
# Q 473 : # joins(:diff_note).where(notes: { project_id: project_id, commit_id: oids })
Query(NoteDiffFile)
.joins('diff_note')
.where("diff_note.project_id = ?")
# Q 474 : # joins(:emails).where(emails: { email: emails })
Query(User)
.joins('emails')
.where("exists(emails, email = ?)")
# Q 475 : # joins(:environment).where(environments: { name: name })
Query(KubernetesNamespace)
.joins('environment')
.where("environment.name = ?")
# Q 476 : # joins(:events).where("events.action = ?", Event::PUSHED)
Query(Project)
.joins('events')
.where("events.action = ?")
# Q 477 : # joins(:groups).where(namespaces: { id: hierarchy_groups })
Query(CiRunner)
.joins('groups')
.where("id = ?")
# Q 478 : # joins(:issues, :notes, :merge_requests).order("issues.created_at, notes.created_at, merge_requests.created_at DESC")
Query(Project)
.joins('issues')
.joins('notes')
.joins('merge_requests')
.order('id, created_at')
# Q 479 : # joins(:merge_request).joins("INNER JOIN project_features ON merge_requests.target_project_id = project_features.project_id").where("project_features.merge_requests_access_level >= :access OR EXISTS(:authorizations)", access: ProjectFeature::ENABLED, authorizations: user.authorizations_for_projects(min_access_level: Gitlab::Access::REPORTER, related_project_column: "merge_requests.target_project_id"))
Query(MergeRequestsClosingIssues)
.joins('merge_request => target_project')
.where("merge_request.target_project.archived = false")
# Q 480 : # joins(:merge_request).joins("INNER JOIN project_features ON merge_requests.target_project_id = project_features.project_id").where("project_features.merge_requests_access_level >= :access", access: ProjectFeature::ENABLED)
Query(MergeRequestsClosingIssues)
.joins('merge_request => target_project')
.where("merge_request.target_project.archived = false")
# Q 481 : # joins(:merge_request).where(merge_requests: { target_project_id: project_id })
Query(MergeRequestDiff)
.joins('merge_request')
.where("merge_request.target_project_id = ?")
# Q 482 : # joins(:merge_request_diff_commits).where(merge_request_diff_commits: { sha: sha }).reorder(nil)
Query(MergeRequestDiff)
.joins('merge_request_diff_commits')
.where("merge_request_diff_commits.sha = ?")
# Q 484 : # joins(:milestones).where("milestones.id" => ids).distinct
Query(Project)
.joins('milestones')
.where("milestones.id IN (?, ?)")
.distinct('')
# Q 485 : # joins(:namespace).where(namespaces: { type: "Group" }).select(:namespace_id)
Query(Project)
.joins('namespace')
.where("namespace.type = ?")
.select('namespace_id')
# Q 486 : # joins(:pages_domain).find_by(pages_domains: { domain: domain_name }, challenge_token: challenge_token)
Query(PagesDomainAcmeOrder)
.joins('pages_domain')
.where("pages_domain.domain = ?")
# Q 487 : # joins(:pages_metadatum).merge(ProjectPagesMetadatum.deployed)
Query(Project)
.joins('pages_metadatum')
.where("pages_metadatum.id = ?")
# Q 488 : # joins(:pages_metadatum).merge(ProjectPagesMetadatum.deployed)
Query(Project)
.joins('pages_metadatum')
.where("pages_metadatum.id = ?")
# Q 489 : # joins(:priorities).where(label_priorities: { project_id: project }).reorder("label_priorities.priority ASC, labels.title ASC")
Query(Label)
.joins('priorities')
.where("priorities.project_id = ?")
.order('id, title')
# Q 490 : # joins(:project).where("projects.visibility_level IN (?)", levels)
Query(Snippet)
.joins('project')
.where('project.visibility_level IN (?, ?)')
# Q 491 : # joins(:project).where(projects: { pending_delete: false })
Query(DeployKeysProject)
.joins('project')
.where("project.pending_delete = false")
# Q 492 : # joins(:projects).where(projects: { namespace_id: namespace_id })
Query(ClustersCluster)
.joins('projects')
.where("projects.namespace_id = ?")
# Q 493 : # joins(:push_event_payload).where(push_event_payloads: { action: actions })
Query(PushEvent)
.joins('push_event_payload')
.where("push_event_payload.action = ?")
# Q 494 : # joins(:push_event_payload).where(push_event_payloads: { ref_type: ref_type })
Query(PushEvent)
.joins('push_event_payload')
.where("push_event_payload.ref_type = ?")
# Q 495 : # joins(:remote_mirrors).where(remote_mirrors: { enabled: true }).distinct
Query(Project)
.joins('remote_mirrors')
.where("remote_mirrors.enabled = true")
.distinct('')
# Q 496 : # joins(:repository_languages).where(repository_languages: { programming_language_id: lang_id_query })
Query(Project)
.joins('repository_languages')
.where("repository_languages.programming_language_id = ?")
# Q 497 : # joins(:runner_projects).where(ci_runner_projects: { project_id: project_id })
Query(CiRunner)
.joins('runner_projects')
.where("runner_projects.project_id = ?")
# Q 498 : # joins(:subscriptions).where(subscriptions: { user_id: user_id, subscribed: true })
# Q 499 : # joins(:target_project)
Query(MergeRequest)
.joins('target_project')
# Q 500 : # joins(:user).group(:source_id).count
# Q 501 : # joins(:user).merge(User.order_name_asc)
Query(UsersStarProject)
.joins('user')
.where("user.name = ?")
# Q 502 : # joins(:user).merge(User.order_name_desc)
Query(UsersStarProject)
.joins('user')
.where("user.name = ?")
# Q 503 : # joins(:user).merge(User.with_public_profile)
Query(UsersStarProject)
.joins('user')
.where('user.private_profile = false')
# Q 504 : # joins(:user).merge(User.with_visible_profile(user))
Query(UsersStarProject)
.joins('user')
.where('user.private_profile = false')
# Q 505 : # joins(project: :project_feature).where(project_features: { column => levels })
Query(Snippet)
.joins("project => project_feature")
.where("project.project_feature.column = ?")